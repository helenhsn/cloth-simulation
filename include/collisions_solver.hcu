#ifndef COLLISION_SOLVER_H
#define COLLISION_SOLVER_H

#include <vector>
#include "mesh.hcu"
#include "bvh.hcu"
#include "cuda_utils.hcu"
#include "simulation_params.h"

// off-chip memory, readable by 100k threads
__constant__ const float EPS = 10e-3f;
__constant__ const int MAX_STACK_SIZE = 64;
__constant__ const float MAX_SCENE_BOUNDS = 100.0;
__constant__ const float CLOTH_THICKNESS = 0.03f; // cloth thickness

struct NodeInfo {
    int index;
    float distToBVH;
};
__device__ inline glm::vec3 interpolateNormal(Triangle &tri, glm::vec4 hitInfo)
{
    return hitInfo.x*tri.normal0 + hitInfo.y*tri.normal1 + hitInfo.z*tri.normal2;
}


__device__ void push(struct NodeInfo* stack, int *size, struct NodeInfo value)
{

    stack[*size] = value;
    *size = *size +1; 
}

__device__ struct NodeInfo &pop(struct NodeInfo* stack, int *size)
{
    *size = *size - 1;
    return stack[*size];
}

__device__ inline glm::vec4 computeIntersection(Triangle &tri, int triIdx, glm::vec4 infos, float det, glm::vec3 dir)
{
    return glm::vec4(tri.p0*infos.x + tri.p1*infos.y +tri.p2*infos.z + infos.w*dir, infos.w)/det;
}

__device__ bool intersectSegmentTriangle(
    int i, 
    int j, 
    int tid, 
    glm::vec3 origin, 
    glm::vec3 dir, 
    Triangle *triangles, 
    GLuint triIdx, 
    glm::vec4 *hitPtInfos
    )
{
    /**
     * Tests if the given ray intersects the given triangle. If successful, returns the barycentric coordinates & distance to origin of the intersection point on the given triangle.
     * */
    
    glm::vec3 qp = -dir;

    Triangle tri = triangles[triIdx];

    glm::vec3 ab = (tri.p1 - tri.p0);
    glm::vec3 ac = (tri.p2 - tri.p0);

    glm::vec3 n = tri.normal; 
    // if (tid==6580 && triIdx==0) printf("\n n = %f %f %f // ab =%f %f %f // ac =%f %f %f // p0 = %f %f %f // p1 = %f %f %f // p2 = %f %f %f ", n.x, n.y, n.z, ab.x, ab.y, ab.z, ac.x, ac.y, ac.z, tri.p0.x, tri.p0.y, tri.p0.z, tri.p1.x, tri.p1.y, tri.p1.z, tri.p2.x, tri.p2.y, tri.p2.z);
    
    float t, u, v, w;
    
    float det = dot(qp, n);
    float res = dot(normalize(qp), normalize(n));
    if (res < EPS) 
    {
        return false; // ray is parallel to or points away from triangle
    }
    
    glm::vec3 ap = (origin - tri.p0);
    t = dot(ap, n);
    glm::vec2 limits = glm::vec2(0.01f, 0.9f)*CLOTH_THICKNESS*det;
    if (t < limits.x || t > limits.y || abs(t) >= abs((*hitPtInfos).w) )
    {
        return false;
    }

    glm::vec3 e = cross(qp, ap); // scalar triple (pq, pa, pc)
    v =  dot(ac, e);
    if (v < -EPS || v - det > EPS) 
    {
        return false; 
    }

    w = -dot(ab, e);
    if (w < -EPS || w - det > EPS) 
    {

        return false;
    }

    u = det - v - w;
    if (u < -EPS)
    {   
        return false;
    }

    *hitPtInfos = computeIntersection(tri, triIdx, glm::vec4(u, v, w, t), det, qp);

    return true;

}

__device__ bool intersectRayAABB(
    int tid, 
    glm::vec3 origin, 
    glm::vec3 dir, 
    glm::vec3 bbmin, 
    glm::vec3 bbmax, 
    float *tNear
    )
{
    /**
     * Checks whether the current ray intersect the given AABB
    */
    
    glm::vec3 sMin = (bbmin - origin)/dir;
    glm::vec3 sMax = (bbmax - origin)/dir;

    glm::vec3 tMin = min(sMin, sMax);
    glm::vec3 tMax = max(sMin, sMax);

    float tNewNear = 0.0;
    float tFar = 100.0;

    for (int i =0; i<3; ++i) 
    {
        if (abs(dir[i]) < EPS)
        {
            if (origin[i] < bbmin[i] || origin[i] > bbmax[i]) {
                return false;
            }

        }
        else
        {
            tNewNear = max(tNewNear, tMin[i]);
            tFar = min(tFar, tMax[i]);

            if (tNewNear > tFar) 
            {
                return false;
            }
        }
    }
    *tNear = tNewNear;
    
    return true;
    
}

__device__ void refitBVRec(
    int idx,
    Node *BVH,
    Triangle *triCloth,
    GLuint *triIdxCloth, 
    glm::vec3 *verticesCloth
)
{
    printf("\nREC idx = %i", idx);
    Node *node = &BVH[idx];

    if (node->triCount != 0) // leaf node 
    {
        node->aabb = {};

        for (int i=0; i<node->triCount; ++i)
        {
            Triangle tri = triCloth[triIdxCloth[node->leftIdx + i]];
            // printf("tri vertices idx = %i %i %i", tri.i0, tri.i1, tri.i2);
            // printf("tri vertices idx = %i %i %i // first val = %f %f %f", tri.i0, tri.i1, tri.i2, verticesCloth[tri.i0].x,  verticesCloth[tri.i0].y,  verticesCloth[tri.i0].z);
            glm::vec3 p0 = verticesCloth[tri.i0];
            glm::vec3 p1 = verticesCloth[tri.i1];
            glm::vec3 p2 = verticesCloth[tri.i2];

            glm::vec3 triMin = min(min(p0, p1), p2);
            glm::vec3 triMax = max(max(p0, p1), p2);

            node->aabb.aabbMin = min(node->aabb.aabbMin, triMin);
            node->aabb.aabbMax = max(node->aabb.aabbMax, triMax);
        }
    } 
    else
    {
        int leftChildIdx = node->leftIdx;
        int rightChildIdx = leftChildIdx + 1;

        refitBVRec(leftChildIdx, BVH, triCloth, triIdxCloth, verticesCloth);
        refitBVRec(rightChildIdx, BVH, triCloth, triIdxCloth, verticesCloth);

        Node  *leftChild = &BVH[leftChildIdx];
        Node  *rightChild = &BVH[rightChildIdx];
        node->aabb.aabbMin = min(leftChild->aabb.aabbMin, rightChild->aabb.aabbMin);
        node->aabb.aabbMax = max(leftChild->aabb.aabbMax, rightChild->aabb.aabbMax);
    }
}

// __device__ void updateAABB(
//     Node *node,
//     Node *leftChild,
//     Node *rightChild
// )
// {
//     node->aabb.aabbMin = min(leftChild->aabb.aabbMin, rightChild->aabb.aabbMin);
//     node->aabb.aabbMax = min(leftChild->aabb.aabbMax, rightChild->aabb.aabbMax);
// }

__global__ void refitLeafNodes(
    int maxTid,
    int **indexData,
    Node *BVH,
    Triangle *triCloth,
    GLuint *triIdxCloth, 
    glm::vec3 *verticesCloth
)
{
    int tid = threadIdx.x + blockIdx.x*blockDim.x;
    if (tid < maxTid)
    {
        int index = indexData[tid][0];
        Node *node = &BVH[index];
        node->aabb = {};

        for (int i=0; i<node->triCount; ++i)
        {
            Triangle tri = triCloth[triIdxCloth[node->leftIdx + i]];
            // printf("tri vertices idx = %i %i %i", tri.i0, tri.i1, tri.i2);
            // printf("tri vertices idx = %i %i %i // first val = %f %f %f", tri.i0, tri.i1, tri.i2, verticesCloth[tri.i0].x,  verticesCloth[tri.i0].y,  verticesCloth[tri.i0].z);
            glm::vec3 p0 = verticesCloth[tri.i0];
            glm::vec3 p1 = verticesCloth[tri.i1];
            glm::vec3 p2 = verticesCloth[tri.i2];

            glm::vec3 triMin = min(min(p0, p1), p2);
            glm::vec3 triMax = max(max(p0, p1), p2);

            node->aabb.aabbMin = min(node->aabb.aabbMin, triMin);
            node->aabb.aabbMax = max(node->aabb.aabbMax, triMax);
        }

    }
}

__global__ void refitParentNodes(
    int maxTid,
    int indexData,
    Node *BVH
)
{
    
}
// __global__ void updateLeafNodes(
//     int maxTid,
//     int N,
//     int **indexData,
//     Node *BVH,
//     Triangle *triCloth,
//     GLuint *triIdxCloth, 
//     glm::vec3 *verticesCloth
// )
// {
//     // int j = threadIdx.x + blockIdx.x*blockDim.x;
//     // int i = threadIdx.y + blockIdx.y*blockDim.y;

//     // int tid = j*N+i;

//     NodeInfo stack[MAX_STACK_SIZE];
//     int stackSize = 0;

//     NodeInfo rootInfo = {0, 0.0f};
//     push(stack, &stackSize, rootInfo);

//     while (stackSize != 0)
//     {
//         NodeInfo &currNodeInfo = pop(stack, &stackSize);
//         Node *currentNode = &BVH[currNodeInfo.index];

//         if (currentNode->triCount != 0)
//         {
//             currentNode->aabb = {};

//             for (int i=0; i<currentNode->triCount; ++i)
//             {
//                 Triangle tri = triCloth[triIdxCloth[currentNode->leftIdx + i]];
//                 // printf("tri vertices idx = %i %i %i", tri.i0, tri.i1, tri.i2);
//                 // printf("tri vertices idx = %i %i %i // first val = %f %f %f", tri.i0, tri.i1, tri.i2, verticesCloth[tri.i0].x,  verticesCloth[tri.i0].y,  verticesCloth[tri.i0].z);
//                 glm::vec3 p0 = verticesCloth[tri.i0];
//                 glm::vec3 p1 = verticesCloth[tri.i1];
//                 glm::vec3 p2 = verticesCloth[tri.i2];

//                 glm::vec3 triMin = min(min(p0, p1), p2);
//                 glm::vec3 triMax = max(max(p0, p1), p2);

//                 currentNode->aabb.aabbMin = min(currentNode->aabb.aabbMin, triMin);
//                 currentNode->aabb.aabbMax = max(currentNode->aabb.aabbMax, triMax);
//             }

//             currentNode->isUpdatedBV = true;


//         }
//         else
//         {
//             NodeInfo leftChildInfo = NodeInfo {currentNode->leftIdx, 0.0f};
//             push(stack, &stackSize, leftChildInfo);
//             Node *leftChild = &BVH[leftChildInfo.index];


//             NodeInfo rightChildInfo = NodeInfo {currentNode->leftIdx+1, 0.0f};
//             push(stack, &stackSize, rightChildInfo);
//             Node *rightChild = &BVH[rightChildInfo.index];

//             if (leftChild->isUpdatedBV && rightChild->isUpdatedBV)
//             {
//                 updateAABB(currentNode, leftChild, rightChild);
//                 leftChild->isUpdatedBV = false;
//                 rightChild->isUpdatedBV = false;
                
//             }
//         }
//     }
// }

__global__ void collisionDetection(
    int colliderId,
    int N, 
    int maxTid, 
    glm::vec3 *origins, 
    glm::vec3 *dirs, 
    Node *BVH, 
    Triangle *triangles, 
    GLuint *triIndices, 
    glm::ivec2 *hitColliderTri, 
    glm::vec4 *hitPointInfo, 
    float factor
    )
{

    int j = threadIdx.x + blockIdx.x*blockDim.x;
    int i = threadIdx.y + blockIdx.y*blockDim.y;

    int tid = j*N+i;

    glm::ivec2 hitColTri = hitColliderTri[tid];
    glm::vec4 hitInfo = hitPointInfo[tid];

    glm::vec3 dir = dirs[tid] * factor;
    
    if (tid < maxTid)
    {
        glm::vec3 origin = origins[tid];

        int rootIndex = 0;
        Node *currentNode = &BVH[rootIndex];

        float tNear;
        if (!intersectRayAABB(tid, origin, dir, currentNode->aabb.aabbMin, currentNode->aabb.aabbMax, &tNear)) 
        {
            return;
        }

        NodeInfo stack[MAX_STACK_SIZE];
        int stackSize = 0;
        
        push(stack, &stackSize, NodeInfo {rootIndex, tNear});

        while (stackSize != 0)
        {
            //printf("\nSTACK SIZE = %i", stackSize);
            NodeInfo &current = pop(stack, &stackSize);
            currentNode = &BVH[current.index];

            

            if (current.distToBVH > MAX_SCENE_BOUNDS) continue;

            if (currentNode->triCount != 0 ) // if the current node is a leaf node -> narrow phase
            {
                for (int k = 0; k < currentNode->triCount; k++)
                {

                    GLuint idx = triIndices[currentNode->leftIdx + k];
                    if (intersectSegmentTriangle(i, j, tid, origin, dir, triangles, idx, &hitInfo))
                    {
                        hitColTri = glm::ivec2(colliderId, idx);
                    }
                }
            }
            else
            {
                // fetching 2 children info and performing BV intersection on them
                NodeInfo leftChildInfo = NodeInfo {currentNode->leftIdx, 0.0f };
                Node *leftChild = &BVH[leftChildInfo.index];
                if (intersectRayAABB(tid, origin, dir, leftChild->aabb.aabbMin, leftChild->aabb.aabbMax, &leftChildInfo.distToBVH)) 
                {
                    push(stack, &stackSize, leftChildInfo);
                }

                NodeInfo rightChildInfo = NodeInfo {currentNode->leftIdx+1, 0.0f};
                Node *rightChild = &BVH[rightChildInfo.index];
                if (intersectRayAABB(tid, origin, dir, rightChild->aabb.aabbMin, rightChild->aabb.aabbMax, &rightChildInfo.distToBVH)) 
                {
                    push(stack, &stackSize, rightChildInfo);
                }
            
            }

        }    
    }

    hitPointInfo[tid] = hitInfo;
    hitColliderTri[tid] = hitColTri;
}


__global__ void collisionResponse(
    int N, 
    int maxTid, 
    glm::vec3 *pos, 
    glm::vec3 *vel, 
    glm::vec3 *OutFBuffer, 
    Triangle **trianglesPtr, 
    glm::ivec2 *hitColliderTri,
    glm::vec4 *hitPointInfo,
    float Kf, 
    float h, 
    float unitM
    )
{
    int j = threadIdx.x + blockIdx.x*blockDim.x;
    int i = threadIdx.y + blockIdx.y*blockDim.y;

    int tid = j*N+i;


    glm::ivec2 hit = hitColliderTri[tid];

    glm::vec3 collisionF = glm::vec3(0.0f);

    if (tid < maxTid)
    {
        if (hit.x > -1 && hit.y > -1)
        {

            // TODO -> tangent & normal velocities => friction coef
            Triangle *tris = trianglesPtr[hit.x];
            glm::vec3 F = OutFBuffer[tid];
            glm::vec3 n = normalize(tris[hit.y].normal);

            float Ncomp = dot(F,n);
            glm::vec3 N = Ncomp*n;
            glm::vec3 R = max(-Ncomp, 0.0f)*n;


            float normN = sqrt(dot(N, N));
            
            glm::vec3 T = F - N;
            float normT = sqrt(dot(T, T));


            glm::vec3 v = vel[tid];
            glm::vec3 vT = v - dot(v,n)*n;
            float normVt = sqrt(dot(vT, vT));

            glm::vec3 friction = glm::vec3(0.0f); //tangential strength
            
            if (normVt > EPS) // kinetic friction
            {
                friction = -Kf*normN*normalize(vT); //  force of friction is always exerted in a direction that opposes movement (for kinetic friction)
            } 
            else 
            { // static friction
                //  force of friction is always exerted in a direction that opposes potential movement (for static friction)
                friction = -T;
                if (normT - Kf*normN > EPS)
                {
                    friction = Kf*normN*normalize(friction);
                }
            }

            if (dot(v, n) < EPS) vel[tid] = vT;
            
            collisionF = R + friction;

            vel[tid] = glm::vec3(0.0f); // velocity needs to be canceled as we don't want the point to keep sinking inside the collider

            glm::vec4 hitInfo = hitPointInfo[tid];
            pos[tid] = glm::vec3(hitInfo.x, hitInfo.y, hitInfo.z) + 0.1f*CLOTH_THICKNESS*n; // slightly offsetting the position of the vertex

        }
    OutFBuffer[tid] = collisionF;
    }
}

__global__ void resetCollisionBuffers(int maxTid, int N, glm::ivec2 *hitIdx, glm::vec4 *infoPt)
{

    int j = threadIdx.x + blockIdx.x*blockDim.x;
    int i = threadIdx.y + blockIdx.y*blockDim.y;

    int tid = j*N+i;
    if (tid < maxTid)
    {
        hitIdx[tid] = glm::ivec2(-10, -10);
        infoPt[tid] = glm::vec4(10e30f);
    }
}

struct Collider
{
    Mesh *colliderPtr;
    BVH *bvh;

    Node *treeCuda;
    Triangle *trianglesCuda;
    GLuint *triIndicesCuda;

    Collider(Mesh *ptr, int nbVertices) : colliderPtr(ptr)
    {
        bvh = new BVH(colliderPtr);
        resetBuffers(nbVertices);

    }

    ~Collider()
    {
        // free everything, including CUDA buffers TODO
    }

    void resetBuffers(int nbVertices)
    {
        // send bvh data to gpu
        cudaErrorCheck(cudaMalloc((void **) &treeCuda, sizeof(Node)* (bvh->getNbNodes()) ));
        cudaErrorCheck(cudaMemcpy(treeCuda, bvh->getTree(), sizeof(Node)*bvh->getNbNodes(), cudaMemcpyHostToDevice));

        cudaErrorCheck(cudaMalloc((void **) &trianglesCuda, sizeof(Triangle)* bvh->getNbTri() ));
        cudaErrorCheck(cudaMemcpy(trianglesCuda, bvh->tri(), sizeof(Triangle) * bvh->getNbTri(), cudaMemcpyHostToDevice));

        cudaErrorCheck(cudaMalloc((void **) &triIndicesCuda, sizeof(GLuint)*bvh->getNbtriIdx()));
        cudaErrorCheck(cudaMemcpy(triIndicesCuda, bvh->triIndices(), sizeof(GLuint)* bvh->getNbtriIdx(), cudaMemcpyHostToDevice));

    }
};

class CollisionSolver
{

    public:
    CollisionSolver(Plane *cloth) : m_verticesNb(cloth->getVerticesNb()) {
        cudaErrorCheck(cudaMalloc((void **) &m_collisionsFBuffer, sizeof(glm::vec3)*m_verticesNb));


        std::vector<glm::vec3> Fbuffers(m_verticesNb, glm::vec3(0.0f));
        cudaErrorCheck(cudaMalloc((void **) &m_collisionsFBuffer, sizeof(glm::vec3)*m_verticesNb));
        cudaErrorCheck(cudaMemcpy(m_collisionsFBuffer, Fbuffers.data(), sizeof(glm::vec3)*m_verticesNb, cudaMemcpyHostToDevice));

        cudaErrorCheck(cudaMalloc((void **) &m_hitColliderTri, sizeof(glm::ivec2)*m_verticesNb));
        cudaErrorCheck(cudaMalloc((void **) &m_hitPointInfo, sizeof(glm::vec4)*m_verticesNb));



    };

    void reset()
    {
        for (auto &collider: m_colliders)
        {
            collider.resetBuffers(m_verticesNb);
        }
    }

    void solve(Plane *cloth, glm::vec3 *v, SimulationParams *params, glm::vec3 *FBuff) 
    {
        //1 KERNEL CALL = update BVs

        // 1 KERNEL CALL = cast rays from 2 directions : normals AND velocity vectorz
        // resolve intersections (intersection AABB/AABB + primary test = ray/triangle intersection)
        // -> fill a bool array saying whether there was a collision or not + another array of 3d vectors containing pt of intersection <?>
        
        
        // 1 KERNEL CALL = add penalty force accordingly  ???
        // Collider updtCollider = m_colliders[(int) m_colliders.size() - 1];
        // int sqrtN = sqrt(updtCollider.bvh->getNbNodes());
        // int roundN = int(ceil(sqrtN+31)/32);
        // dim3 gridBVHCloth(1, 1, 1);
        // dim3 blockBVHCloth(1, 1, 1);
        // updateBVH<<<gridBVHCloth, blockBVHCloth>>>(
        //     updtCollider.bvh->getNbNodes(), 
        //     sqrtN,
        //     updtCollider.treeCuda, 
        //     updtCollider.trianglesCuda,
        //     updtCollider.triIndicesCuda,a
        //     (glm::vec3 *) updtCollider.colliderPtr->getDataPtr(0)
        //     );
        // cudaErrorCheck(cudaDeviceSynchronize());
        dim3 gridDim((cloth->N() + 31)/32, (cloth->N() + 31)/32, 1);
        dim3 blockDim(32, 32, 1);


        resetCollisionBuffers<<<gridDim, blockDim>>>(cloth->getVerticesNb(), cloth->N(), m_hitColliderTri, m_hitPointInfo);

        for (int i=0; i< (int) m_colliders.size(); ++i)
        {   
            auto &collider = m_colliders[i];

            for (float dir = -1.0; dir < 2.0; dir+=2.0)
            {
                // raytracing using velocity
                collisionDetection<<<gridDim, blockDim>>>(
                    i,
                    cloth->N(), 
                    cloth->getVerticesNb(), 
                    (glm::vec3 *) cloth->getDataPtr(0),
                    (glm::vec3 *) cloth->getDataPtr(1),
                    collider.treeCuda,
                    collider.trianglesCuda,
                    collider.triIndicesCuda,
                    m_hitColliderTri,
                    m_hitPointInfo,
                    dir
                );
                cudaErrorCheck(cudaDeviceSynchronize());
            }
        }
        collisionResponse<<<gridDim, blockDim>>>(
            cloth->N(), 
            cloth->getVerticesNb(),
            (glm::vec3 *) cloth->getDataPtr(0),
            v,
            m_collisionsFBuffer,
            m_trisPtr,
            m_hitColliderTri,
            m_hitPointInfo,
            params->Kf,
            params->timeStep,
            params->unitM
        );
        cudaErrorCheck(cudaDeviceSynchronize());


    };

    void addCollider(Mesh *colliderMesh)
    {
        Collider collider(colliderMesh, m_verticesNb);
        m_colliders.push_back(collider);
        m_colTriCudaPtrs.push_back(collider.trianglesCuda);

        if (m_trisPtr) cudaFree(m_trisPtr);
        cudaErrorCheck(cudaMalloc((void **) &m_trisPtr, sizeof(Triangle *)*m_colTriCudaPtrs.size()));
        cudaErrorCheck(cudaMemcpy(m_trisPtr, m_colTriCudaPtrs.data(), sizeof(Triangle *)*m_colTriCudaPtrs.size(), cudaMemcpyHostToDevice));
    };

    glm::vec3 *collisionsFBuffer() {return m_collisionsFBuffer;};

    void bindCollidersCudaData()
    {
        for (auto &collider: m_colliders)
        {
            collider.colliderPtr->bindCudaData();
        }
    }

    void unBindCollidersCudaData()
    {
        for (auto &collider: m_colliders)
        {
            collider.colliderPtr->unbindCudaData();
        }
    }

    private:

    std::vector<Collider> m_colliders;

    std::vector<Triangle *> m_colTriCudaPtrs; // stores CUDA pointers to colliders' triangles
    Triangle **m_trisPtr = nullptr;

    int m_verticesNb;

    glm::vec3 *m_collisionsFBuffer;
    glm::ivec2 *m_hitColliderTri;
    glm::vec4 *m_hitPointInfo;


};

#endif